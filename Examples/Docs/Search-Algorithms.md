## Search Algorithms
Discrete optimization forms a class of computationally expensive problems which search algorithms systematically search the space of possible solutions subject to constraints of the problem. The set *S* is a finite or countably infinite set of all solutions that satisfy specified constraints. The function *f* is the cost function that maps each element to a value. The solution to a discrete optimization problem is to find a node *x* in *S* which satisfys *f(x)* <= *f(x<sub>opt</sub>)*.

### Sequential Search Algorithms

#### Depth-First Search
Applies to search spaces that are trees. It begins by expanding the initial node and generating its successors. In each subsequent step, DFS expands one of the most recently generated nodes; if there is no successor to a node, its backtracks to the parent to explore a differnt child. Ordering the generated nodes makes it a directed DFS. An optimization is bounding the deepth of a branch to make sure no possible solution exists within the upper range before expanding the search.

#### Best-First Search
BFS algorithms use a heuristic function to guide its search. The core data structure is a list, called Open list, that stores unexplored nodes sorted on their heuristic estimates. The best node is selected from the list, expanded, and its offspring are inserted at the right position. If the heuristic is admissible, the BFS finds the optimal solution.

### Parallel Search Algorithms

#### Depth-First Search
Since the search space is unknown it is difficult to partition the work across the CPUs to deliver on good load balancing. When a processor runs out of work, it gets more work from another processor. This is done using work requests and responses in message passing machines and locking and extracting work in shared address space machines. Techniques for this are _Async Round Robin_ (processes work on their section and ask for work when the complete their section), _Global Round Robin_ (next node is taken from list of avaiable requires syncronization), _Random Pooling_ (a different CPU is pinged for work after each request). The next problem is how to know the all processes have completed searching. Dijkstraâ€™s Token assumes that all processors are organized in a logical ring and that work transfers can only happen from P<sub>*i*</sub> to P<sub>*j*</sub> if *j* > *i*. P<sub>0</sub> passes it to the next CPU when it goes idle, which is repeated around the ring until P<sub>0</sub> recieves the token singalling work is compelete. Removing the work transfer rule we also add coloring to the token; when the token is transfered forward (P<sub>*i*</sub> to P<sub>*j*</sub> when *j* > *i*) it is colored green, otherwise its colored red. The program terminates when P<sub>0</sub> recieves the green token and is idle. An alternative to this is a Tree based weight, when the program starts P<sub>0</sub> has a weight of 1.0. When new nodes are generated by the search the parent node devides its weight equal amoung its children node. When a node and all its children are complete its wight is summed to that of its parent. the program terminates when P<sub>0</sub> returns to a weight of 1.0.

